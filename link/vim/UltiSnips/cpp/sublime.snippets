snippet beginend_ "std::begin($1), std::end($1)" b
begin(${1:v}), end(${1:v})
endsnippet

snippet bintempfunctor "Binary Template Functor" b
struct ${1:name} {
	template<typename T, typename U>
	constexpr auto operator()(T&& t, U&& u) const noexcept -> decltype(${2:/* code */}) {
		return ${2:/* code */};
	}
};
endsnippet

snippet lamref "Lambda – Catch All by Reference" b
[&](${1:/* args */}) {
	${2:/* code */}
}
endsnippet

snippet lamval "Lambda – Catch All by Value" b
[=](${1:/* args */}) {
	${2:/* code */}
}
endsnippet

snippet clanggreater "Clang Version &gt;= Check" b
defined(__clang__) && ((__clang_major__ > ${1:3}) || (__clang_major__ == ${1:3}) && (__clang_minor__ >= ${2:2}))
endsnippet

snippet clangless "Clang Version &lt;= Check" b
defined(__clang__) && ((__clang_major__ < ${1:3}) || (__clang_major__ == ${1:3}) && (__clang_minor__ <= ${2:2}))
endsnippet

snippet class_ "Class" b
class ${1:${TM_FILENAME/(.+)\..+|.*/$1/:name}} {
private:
	${2:/* data */}
public:
	${1/(\w+).*/$1/}(${3:/* args */}) ${4:= default;}
};
endsnippet

snippet classtemp "Class Template" b
template<typename ${1:T}>
class ${2:${TM_FILENAME/(.+)\..+|.*/$1/:name}} {
private:
	${3:/* data */}
public:
	${2/(\w+).*/$1/}(${4:/* args */}) ${5:= default;}
};
endsnippet

snippet confunct "Constexpr Function" b
constexpr ${1:int} ${2:function_name}(${3:/* args */}) {
	return ${0:/* code */};
}
endsnippet

snippet declv "std::declval&lt;T&gt;()" b
std::declval<${1:T}>()
endsnippet

snippet do_ "Do While Loop" b
do {
	${0:/* code */}
} while (${1:/* condition */});
endsnippet

snippet excep "Create exception" b
class ${1:${TM_FILENAME/(.+)\..+|.*/$1/:name}} : public ${2:std::runtime_error} {
public:
	${1/(\w+).*/$1/}(const std::string& str): ${2:std::runtime_error}(${3:str}) {}
};
endsnippet

snippet for_ "For Loop" b
for(unsigned ${2:i} = 0; $2 < ${1:count}; ${3:++$2}) {
	${0:/* code */}
}
endsnippet

snippet forw "std::forward&lt;T&gt;(…)" b
std::forward<${1:T}>(${2:t})
endsnippet

snippet lamfull "Lambda – Full Spec" b
[${1:/* capture */}](${2:/* args */}) ${3:mutable} ${4:noexcept} -> ${5:/* return */} {
	${6:/* code */}
}
endsnippet

snippet functor "Functor" b
struct ${1:name} {
	${2:bool} operator()(${3:/* args */}) const noexcept {
		${0:/* code */}
	}
};
endsnippet

snippet gccgreater "GCC Version &gt;= Check" b
defined(__GNUC__) && ((__GNUC__ > ${1:4}) || ((__GNUC__ == ${1:4}) && (__GNUC_MINOR__ >= ${2:7})))
endsnippet

snippet gccless "GCC Version &lt;= Check" b
defined(__GNUC__) && ((__GNUC__ < ${1:4}) || ((__GNUC__ == ${1:4}) && (__GNUC_MINOR__ <= ${2:7})))
endsnippet

snippet ifelifpre "#if … #elif … #else" b
#if ${1:/* condition */}
${2:/* code */}
#elif ${3:/* condition */}
${4:/* code */}
#else
${0:/* code */}
#endif
endsnippet

snippet ifelif "if(…) else if(…) else" b
if(${1:/* condition */}) {
	${2:/* code */}
}
else if(${3:/* condition */}) {
	${4:/* code */}
}
else {
	${0:/* code */}
}
endsnippet

snippet ifelsepre "#if … #else" b
#if ${1:/* condition */}
${2:/* code */}
#else
${0:/*code */}
#endif
endsnippet

snippet ifelse "if(…) else" b
if(${1:/* condition */}) {
	${2:/* code */}
}
else {
	${0:/* code */}
}
endsnippet

snippet ifnd "ifndef (…)" b
#ifndef $1
#define ${1:${TM_FILENAME/(([A-Z])([A-Z][a-z]))|(([a-z])([A-Z]))|([a-z])|(\.)/\U(?1:$2_$3)(?4:$5_$6)$7(?8:_)\E/g}}
${0}
#endif // $1
endsnippet

snippet if_ "if(…)" b
if(${1:/* condition */}) {
	${0:/* code */}
}
endsnippet

snippet cpptraitfun "Do While Loop" b
struct ${1:my_trait}_impl {
	template<typename T, ${$2:/* expression SFINAE here */}>
	static std::true_type test(int);
	template<typename...>
	static std::false_type test(...);
};
template<typename T>
struct ${1:my_trait} : decltype(${1:my_trait}_impl::test<T>(0)) {};
$0
endsnippet

snippet lamret "Lambda – Explicit Return Declaration" b
[${1:/* capture */}](${2:/* args */}) -> ${3:/* return */} {
	${4:/* code */}
}
endsnippet

snippet main_ "main(…)" b
int main(int argc, char const *argv[]) {
	${1:/* code */}
	return 0;
}
endsnippet

snippet lammin "Lambda – Minimal" b
[${1:/* capture */}] {
	${2:/* code */}
}
endsnippet

snippet mitl "MIT License" b
// The MIT License (MIT)
// Copyright (c) ${1:YEAR} ${2:NAME}
//  Permission is hereby granted, free of charge, to any person obtaining a
//  copy of this software and associated documentation files (the "Software"),
//  to deal in the Software without restriction, including without limitation
//  the rights to use, copy, modify, merge, publish, distribute, sublicense,
//  and/or sell copies of the Software, and to permit persons to whom the
//  Software is furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
//  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
${0:/* code */}
endsnippet

snippet name "Namespace" b
namespace ${1:name} {
	$0
} // $1
endsnippet

snippet forrange "Range-based For Loop" b
for(auto&& ${1:i} : ${2:v}) {
	$0
}
endsnippet

snippet funct "Regular Function" b
${1:int} ${2:function_name}(${3:/* args */}) {
	${0:/* code */}
}
endsnippet

snippet returns "-&gt; decltype(…)" b
-> decltype(${1:/* code */}) {
	return ${1:/* code */};
}
endsnippet

snippet struct_ "Struct" b
struct ${1:${TM_FILENAME/(.+)\..+|.*/$1/:name}} {
	${0:/* data */}
};
endsnippet

snippet structtemp "Templated Struct" b
template<typename ${1:T}>
struct ${2:${TM_FILENAME/(.+)\..+|.*/$1/:name}} {
	${0:/* code */}
};
endsnippet

snippet tempcfunca "Template Auto Constexpr Function" b
template<typename ${1:T}>
constexpr auto ${2:function_name}(${3:/* args */}) noexcept -> decltype(${4:/* code */}) {
	return ${4:/* code */};
}
endsnippet

snippet tempfunca "Template Auto Function" b
template<typename ${1:T}>
auto ${2:function_name}(${3:/* args */}) -> decltype(${4:/* expression */}) {
	${0:/* code */}
}
endsnippet

snippet tempcfunc "Template Constexpr Function" b
template<typename ${1:T}>
constexpr ${2:int} ${3:function_name}(${4:/* args */}) {
	return ${5:/* code */};
}
endsnippet

snippet tempfunc "Templated Function" b
template<typename ${1:T}>
${2:int} ${3:function_name}(${4:/* args */}) noexcept {
	$0
}
endsnippet

snippet tem "Template" b
template<typename ${1:T}>
endsnippet

snippet try "Try Catch Block" b
try {
	${1:/* code */}
}
catch(${2:const std::exception& e}) {
	${0:std::cerr << e.what() << '\n';}
}
endsnippet

snippet tempfunctor "Unary Template Functor" b
struct ${1:name} {
	template<typename T>
	constexpr auto operator()(T&& t) const noexcept -> decltype(${2:/* code */}) {
		return ${2:/* code */};
	}
};
endsnippet

snippet usings "Using Statement" b
using ${1:my_type} = ${2:int};
endsnippet

snippet usingt "Using Statement (Templated)" b
template<typename ${1:T}>
using ${2:Type} = ${3:typename T::type};
endsnippet

snippet temv "Variadic Template" b
template<typename... ${1:Args}>
endsnippet

snippet while "While Loop" b
while(${1:/* condition */}) {
	${2:/* code */}
}
endsnippet
