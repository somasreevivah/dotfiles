#######################################################################
#                                TYPES                                #
#######################################################################

snippet const "Constant value" b
${1:TYPE}, PARAMETER :: $2 = $0
endsnippet


# int
########

snippet int "Definition of int type" b
INTEGER :: ${1:variable_name} ${2:=42}
endsnippet
snippet cint "Definition of constants of int type" b
INTEGER, PARAMETER :: ${1:variable_name} ${2:=42}
endsnippet

# bool
########

snippet bool "Definition of bool type" b
LOGICAL :: ${1:variable_name} ${2:=.TRUE.}
endsnippet
snippet cbool "Definition of constants of bool type" b
LOGICAL, PARAMETER :: ${1:variable_name} ${2:=.TRUE.}
endsnippet

# float
########

snippet float "Definition of real type" b
REAL :: ${1:variable_name} ${2:=42}
endsnippet
snippet cfloat "Definition of constants of real type" b
REAL, PARAMETER :: ${1:variable_name} ${2:=42}
endsnippet

# double
########

snippet double "Definition of double type" b
DOUBLE PRECISION :: ${1:variable_name} ${2:=42}
endsnippet
snippet cdouble "Definition of constants of double type" b
DOUBLE PRECISION, PARAMETER :: ${1:variable_name} ${2:=42}
endsnippet

# str
########

snippet str "Definition of str type" b
CHARACTER(LEN=*) :: ${1:variable_name} ${2:="AAAAA"}
endsnippet
snippet cstr "Definition of constants of str type" b
CHARACTER(LEN=*), PARAMETER :: ${1:variable_name} ${2:="AAAAAA"}
endsnippet


# char
########

snippet char "Definition of char type" b
CHARACTER(LEN=1) :: ${1:variable_name} ${2:="A"}
endsnippet
snippet cchar "Definition of constants of char type" b
CHARACTER(LEN=1), PARAMETER :: ${1:variable_name} ${2:="A"}
endsnippet


# arr
########

snippet arr
${1:TYPE}, ALLOCATABLE, DIMENSION(${2::}) :: $0
endsnippet
snippet carr "Definition of constants of arr type" b
${1:TYPE}, ALLOCATABLE, DIMENSION(${2::}), PARAMETER :: $0
endsnippet


# Structs
########

snippet struct
TYPE(${1:NAME})
! ${2:e.g: TYPE ($1) :: var}
$0
END TYPE $1
endsnippet


# fun
########

snippet fun "Definition of fun type" b
FUNCTION ${1:function_name}(${2:arguments}) RESULT(${3:result_variables})
	${4:${5:input_type}, INTENT(IN)  :: $2} ! input
	${6:${7:output_type}, INTENT(OUT):: $3} ! output$0
END FUNCTION $1
endsnippet

# hex
########
snippet hex "hex number" b
z'${1:aef123}'
endsnippet

# bin
########
snippet bin "Binary digit" i
b'${1:11111}'
endsnippet

# octal
########
snippet octal "Octal number" b
o'${1:123674}'
endsnippet


# module
#######

snippet module
MODULE ${1:MODULENAME}
IMPLICIT NONE
	$0
END MODULE $1
endsnippet

#######################################################################
#                                UTILS                                #
#######################################################################

snippet so "Stdout" b
WRITE(*,*) $0
endsnippet

snippet so "Stdout" b
WRITE(2,*) $0
endsnippet

snippet fread
READ( UNIT = ${1:FP}, FILE = ${2:FILENAME}${3:, IOSTAT = IERR }) $0
endsnippet


snippet fwrite
WRITE( UNIT = ${1:FP}, FILE = ${2:FILENAME}${3:, IOSTAT = IERR }) $0
endsnippet


snippet fopen
OPEN (UNIT = ${1:FP}, FILE = ${2:FILENAME}, STATUS = UNKNOWN${3:, IOSTAT = IERR }) $0
endsnippet


snippet fclose
CLOSE ( UNIT = ${1:FP} ) $0
endsnippet

#snippet read "Stdin read" b
#read ${1:-p ${2:"Prompt message:"}} ${3:variable_name}$0
#endsnippet

#snippet cd "Change directory" b
#cd ${1:folder}$0
#endsnippet

#snippet mkdir "Make directory" b
#mkdir -p ${1:/path/to/dir}$0
#endsnippet

#snippet exit "Exit function" b
#exit ${1:0}$0
#endsnippet

snippet ret "Return statement" b
RETURN
endsnippet

#snippet pac "Import package" b
#source ${1:path/to/package.sh}$0
#endsnippet

#snippet argc "Get arguments number" i
#$#$0
#endsnippet

#snippet argvi "Get ith argument" i
#\$${1:i}$0
#endsnippet



#######################################################################
#                              BRANCHING                              #
#######################################################################

snippet if
IF (${1:CONDITION}) THEN
	$2
END IF
endsnippet

#snippet elif "If branching" b
#elif ${2:[[ ${1:condition} ]]}; then
	#${0:#statements}
#endsnippet

snippet ife "If else" b
IF (${1:CONDITION}) THEN
	$2
ELSE
	$3
END IF
endsnippet

#snippet ifsh "If branching" b
#if ${2:[[ ${1:condition} ]]}; then ${0:#statements} fi
#endsnippet

#snippet if3 "If branching" b
#${2:[[ ${1:condition} ]]} && ${3:success statements} || ${3:error statements}
#endsnippet

#snippet until "until ... (done)" b
#until ${2:[[ ${1:condition} ]]}; do
	#${0:#statements}
#done
#endsnippet

snippet while "While loop" b
DO WHILE (${1:condition})
	$2
END DO
endsnippet

snippet for
DO ${1:I} = ${2:START},${3:END}, ${4:INCR}
	$4
END DO
endsnippet

snippet case
SELECT CASE (${1:expr})
	CASE ($2)
	CASE DEFAULT
	$3
END SELECT $0
endsnippet

#snippet fori "for something in somewhere" b
#for ${1:needle} in ${2:haystack} ; do
	#${0:#statements}
#done
#endsnippet



#######################################################################
#                              CONSTANTS                              #
#######################################################################

snippet true "True value" i
.TRUE.
endsnippet
snippet false "True value" i
.FALSE.
endsnippet
snippet and "and operator" i
.AND.
endsnippet
snippet or "Or operator" i
.OR.
endsnippet
#snippet bor "Bitwise or" i
#|
#endsnippet
#snippet band "Bitwise and" i
#&
#endsnippet

#######################################################################
#                              TEMPLATES                              #
#######################################################################

snippet main
PROGRAM ${1:MAIN}
IMPLICIT NONE
	$0
END PROGRAM $1
endsnippet
