

### TYPES {{{1


snippet fun "Simple function definition" b
FUNCTION ${1:function_name}(${2:arguments}) RESULT(${3:result_variables})
	${4:${5:input_type}, INTENT(IN)  :: $2} ! input
	${6:${7:output_type}, INTENT(OUT):: $3} ! output$0
END FUNCTION $1
endsnippet
#snippet lambda "Lambda expression" b
#endsnippet
#snippet class "Class definition" b
#endsnippet
#snippet met "Method of a class" b
#endsnippet
#snippet attr "Attribute of a class" b
#endsnippet
snippet const "Readonly variale" b
${1:TYPE}, PARAMETER :: $2 = $0
endsnippet
#snippet macro "C-like macro" b
#endsnippet
snippet int "Simple integer definition" b
INTEGER :: ${1:variable_name} ${2:=42}
endsnippet
snippet float "Simple floating point definition" b
REAL :: ${1:variable_name} ${2:=42}
endsnippet
snippet double "Double precission" b
DOUBLE PRECISION :: ${1:variable_name} ${2:=42}
endsnippet
snippet char "Character definition" b
CHARACTER(LEN=1) :: ${1:variable_name} ${2:="A"}
endsnippet
snippet str "String definition" b
CHARACTER(LEN=*) :: ${1:variable_name} ${2:="AAAAA"}
endsnippet
#snippet dic "Relational array" b
#endsnippet
snippet arr "List of values" b
${1:TYPE}, ALLOCATABLE, DIMENSION(${2::}) :: $0
endsnippet
#snippet pointer "Pointer-like variable" b
#endsnippet
#snippet reference "Reference-like variable" b
#endsnippet
#snippet enum "Enumeration definition" b
#endsnippet
snippet struct "Structure construct" b
TYPE(${1:NAME})
! ${2:e.g: TYPE ($1) :: var}
$0
END TYPE $1
endsnippet
#snippet type "Define custom type" b
#endsnippet
snippet bin "Binary numbers" b
b'${1:11111}'
endsnippet
snippet hex "Hexadecimal numbers" b
z'${1:aef123}'
endsnippet
snippet octal "Octal numbers" b
o'${1:123674}'
endsnippet
snippet bool "Boolean variables" b
LOGICAL :: ${1:variable_name} ${2:=.TRUE.}
endsnippet
#snippet name "Namespace" b
#endsnippet
snippet module "Define module, package etc.." b
MODULE ${1:MODULENAME}
IMPLICIT NONE
	$0
END MODULE $1
endsnippet
#snippet c<TYPE> "Constant type definition" b
#endsnippet
#snippet t<TYPE> "Type safe definition" b
#endsnippet
#snippet ct<TYPE> "Constant type safe definition" b
#endsnippet
#snippet a<TYPE> "Array 1D type definition" b
#endsnippet
#snippet ca<TYPE> "Array 1D type definition" b
#endsnippet


### BRANCHING {{{1


snippet if "If construct" 
IF (${1:CONDITION}) THEN
	$2
END IF
endsnippet
snippet ife "If else construct" b
IF (${1:CONDITION}) THEN
	$2
ELSE
	$3
END IF
endsnippet
#snippet elif "Else if construct" b
#endsnippet
#snippet else "Just else" b
#endsnippet
#snippet ifsh "If construct, short form" b
#endsnippet
#snippet if3 "If construct tertiary form" b
#endsnippet
snippet for "For with index" b
DO ${1:I} = ${2:START},${3:END}, ${4:INCR}
	$4
END DO
endsnippet
#snippet fori "For in iterator form" b
#endsnippet
#snippet ford "For in dictionary/table form" b
#endsnippet
snippet while "While loop" b
DO WHILE (${1:condition})
	$2
END DO
endsnippet
#snippet until "Until loop" b
#endsnippet
snippet case "Case construct" b
SELECT CASE (${1:expr})
	CASE ($2)
	CASE DEFAULT
	$3
END SELECT $0
endsnippet
#snippet try "Try/catch" b
#endsnippet
#snippet ifm "If regex match" b
#endsnippet


### UTILS {{{1


#snippet new "Instantiate object" b
#endsnippet
#snippet pac "Include some package" b
#endsnippet
snippet so "Print to stdout" b
WRITE(*,*) $0
endsnippet
snippet serr "Print to stderr" b
WRITE(2,*) $0
endsnippet
#snippet sex "Raise exception" b
#endsnippet
#snippet sof "Printf to stdout (formated)" b
#endsnippet
#snippet read "Stdin read" b
#endsnippet
#snippet cd "Change dir" b
#endsnippet
#snippet ls "List directory" b
#endsnippet
#snippet sys "Talk to the shell" b
#endsnippet
#snippet mkdir "Create directory" b
#endsnippet
#snippet cp "Copy a file" b
#endsnippet
#snippet cpr "Copy dir" b
#endsnippet
snippet fopen "File open" b
OPEN (UNIT = ${1:FP}, FILE = ${2:FILENAME}, STATUS = UNKNOWN${3:, IOSTAT = IERR }) $0
endsnippet
snippet fclose "File open" b
CLOSE ( UNIT = ${1:FP} ) $0
endsnippet
snippet fwrite "File write" b
WRITE( UNIT = ${1:FP}, FILE = ${2:FILENAME}${3:, IOSTAT = IERR }) $0
endsnippet
snippet fread "File read" b
READ( UNIT = ${1:FP}, FILE = ${2:FILENAME}${3:, IOSTAT = IERR }) $0
endsnippet
#snippet exit "Exit a program with status" b
#endsnippet
snippet ret "Return a value in function" b
RETURN
endsnippet
#snippet argc "Get arguments number" b
#endsnippet
#snippet argvi "Get ith argument" b
#endsnippet
#snippet match "Regex match" b
#endsnippet
#snippet sizeof "Get size of variables or types" b
#endsnippet
#snippet basename "Bash basename" b
#endsnippet
#snippet genv "Get Environment variables" b
#endsnippet
#snippet senv "Set Environment variables" b
#endsnippet
#snippet clear "stdout clear" b
#endsnippet
#snippet sleep "Sleep for some time" b
#endsnippet
#snippet shbang "Shbang for some scripting languages" b
#endsnippet
#snippet slurp "Slurp, read a whole file at once" b
#endsnippet


### CONSTANTS {{{1


snippet true "True variable" b
.TRUE.
endsnippet
snippet false "False keyword" b
.FALSE.
endsnippet
snippet and "And operator" b
.AND.
endsnippet
snippet or "Or operator" b
.OR.
endsnippet
#snippet bor "Bitwise or" b
#endsnippet
#snippet band "Bitwise and" b
#endsnippet
#snippet nan "Not a number" b
#endsnippet
#snippet null "Undefined variable" b
#endsnippet
#snippet eof "End of file character" b
#endsnippet


### TEMPLATES {{{1


#snippet argv-parse "Parse command line" b
#endsnippet
snippet main "Main template" b
PROGRAM ${1:MAIN}
IMPLICIT NONE
	$0
END PROGRAM $1
endsnippet
