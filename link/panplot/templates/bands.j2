unitsize(1cm);
currentpen = fontsize(1cm);
import patterns;

add("hatch", hatch());

real max_energy = {{ get_max_energy(states)  }};
real min_energy = {{ get_min_energy(states)  }};
real figure_height = 10;
real state_width = 10;
real state_height = 1;
real value;
real energy_to_value(real energy) {
  return figure_height * (energy - min_energy) / max_energy;
}
pair base, diagonal;

{% for state in states %}
//{{state }}

{% if state.spin == 1 %}
  {%- set color = "blue" -%}
  {%- set xcord = 0 -%}
{%- elif state.spin == 2 -%}
  {%- set color = "red" -%}
  {%- set xcord = "state_width/2" -%}
{%- else -%}
  {%- set color = "black" -%}
  {%- set xcord = 0 -%}
{% endif %}

base = ({{xcord}}, energy_to_value({{state.energy}}));
diagonal = ({{xcord}} + state_width, energy_to_value({{state.energy}}) + state_height);
filldraw(
  box(base, diagonal),
  {{color}}{% if state.occupation | float < 0.01 %} + pattern("hatch") {% endif %},
  black+linewidth(0)
);

label(
  scale(4.3)*"{{state.band}}",
  base +
  ({{state.spin}}>0 ? {{state.spin}} - 1 : 1) * (state_width, 0) +
  (0, 0.5 * state_height),
  0.2*{{color}}
);

{% endfor %}


{#

/*

unitsize(.2cm);

struct state {
  static int state_count;
  real energy;
  real occupation;
  real band;
  real value;
  pen color;
  pen spin_color;
  pen spin_occupied_color = black;
  pen spin_unoccupied_color = 0.7*white+dashed;
  pen occupied_color = red;
  pen unoccupied_color = gray;
  string title = "";
  real spin = 0;
  real VB = ENERGIE_VB_PRISTINE;
  real LB = ENERGIE_LB_PRISTINE;
  real DASH_WIDTH = 25;
  real DASH_HEIGHT = 1.8;
  real X_COORD = 0;
  real Y_OFFSET = 0;
  real OCCUPATION_CUTOFF = 0.1;
  real getPlottingValue (){
    real val = 100*(energy - VB)/(LB-VB);
    return val + Y_OFFSET;
  };
  bool isOccupied(){
    if ( occupation >= OCCUPATION_CUTOFF ) {
      return true;
    } else {
      return false;
    }
  };
  state setStyle(){
    real parameter;
    if ( spin != 0 ) {
      parameter = occupation;
    } else {
      parameter = occupation/2;
    }
    color = parameter*occupied_color+(1-parameter)*unoccupied_color;
    spin_color = parameter*spin_occupied_color+(1-parameter)*spin_unoccupied_color+linewidth(3);
    return this;
  };
  void operator init(real energy, real spin, real occupation, real band){
    this.energy = energy;
    this.occupation = occupation;
    this.band = band;
    this.spin = spin;
    this.value = getPlottingValue();
    state_count    += 1;
    setStyle();
  };
  pair getMiddlePoint (  ){
    real x,y;
    x = X_COORD+(DASH_WIDTH)/2;
    y = value + (DASH_HEIGHT)/2;
    return (x,y);
  };
  state setColors (pen color, pen spin_color=this.spin_color){
    this.color = color;
    this.spin_color = spin_color;
    return this;
  };
  state setAutoPosition (){
    int controller = state_count%%2;
    X_COORD=0+controller*(DASH_WIDTH);
    return this;
  };
  bool  isLeft (){
    if ( getMiddlePoint().x >= IMG_WIDTH/2 ) {
      return false;
    }
    else{
      return true;
    }
  };
  bool isUp (){   return spin == 1?true:false; };
  bool isDown (){ return spin == 2?true:false; };
  pair getSpinPosition (bool up=false){
    real x_deviation = 0.25*DASH_WIDTH;
    pair middle = getMiddlePoint();
    if (up) {
      return (middle - (-x_deviation,0));
    } else {
      return (middle + (-x_deviation,0));
    }
  };
  path getSpinArrow (){
    bool up = isUp();
    pair position = getSpinPosition(up);
    real height = 3*DASH_HEIGHT;
    if (isUp()) {
      return position - (0,height/2) -- position + (0,height/2);
    } else {
      return position + (0,height/2) -- position - (0,height/2);
    }
  };
  state draw_energy (){
    if ( isLeft() ) {
      label((string)energy, (X_COORD,value), W, red);
    } else {
      label((string)energy, (X_COORD+DASH_WIDTH, value), E, red);
    }
    return this;
  };
  state draw_spin(){
    path spinArrow = getSpinArrow();
    draw(spinArrow, spin_color,Arrow(15));
    return this;
  };
  state draw (
      bool draw_band = false,
      bool draw_occupation = true,
      bool draw_energy = true
      ){
    filldraw(
        box(
          (X_COORD,value)
          ,(X_COORD+DASH_WIDTH,value+DASH_HEIGHT)
          ),
        color,color*0
        );
    if ( draw_band )
      label(scale(1)*(string)band       , getMiddlePoint() - (DASH_WIDTH/4 , 0) , black);
    if ( draw_occupation && occupation != 0)
      label(scale(1)*(string)occupation , getSpinPosition(!isUp()) , black);
    if ( draw_energy ) draw_energy();
    if ( spin != 0 ) draw_spin();
    return this;
  };
};

  #}

{# vim: nospell ft=asy.jinja
#}
